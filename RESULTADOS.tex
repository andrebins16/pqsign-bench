Entre os algoritmos clássicos, o ECDSA apresentou o melhor desempenho geral, destacando-se em praticamente todos os cenários de tempo de processamento. O RSA manteve resultados muito próximos nas operações de assinatura e verificação, mas foi fortemente penalizado na geração de chaves — etapa em que o custo de criação de primos é extremamente alto. Esse fator elevou o tempo total do ciclo completo, embora, na prática, a operação de \textit{keygen} ocorra com muito menor frequência em aplicações reais, o que faz o RSA continuar competitivo em uso cotidiano.


Na geração de chaves, o ML-DSA apresentou os melhores resultados entre os algoritmos pós-quânticos, com tempos muito próximos aos do ECDSA e amplamente superiores aos do RSA. As variantes \textit{f-simple} do SPHINCS+ também mostraram desempenho satisfatório, situando-se logo atrás do ML-DSA, enquanto o Falcon apresentou tempos um pouco maiores, embora ainda dentro de uma faixa aceitável. De modo geral, todos os algoritmos pós-quânticos superaram com folga o RSA nessa etapa, evidenciando que o custo de geração de chaves não representa um obstáculo relevante para sua adoção prática.


Nas operações de assinatura, ML-DSA e Falcon obtiveram tempos praticamente equivalentes entre si e muito competitivos em mensagens pequenas e médias (256~bytes e 100~kB). Em mensagens grandes (100~MB), ambos continuaram apresentando resultados aceitáveis, principalmente no Raspberry Pi, onde mantiveram desempenho próximo dos clássicos. No Ubuntu para mensagens grandes, os tempos do ML-DSA e Falcon cresceram consideravelmente em relação aos algoritmos clássicos, mas ainda dentro de uma faixa viável. Nessa faixa de tamanho, algumas variantes \textit{f-simple} do SPHINCS+–SHA2, especialmente a SHA2-128f, chegaram a superar ML-DSA e Falcon, o que as torna alternativas plausíveis para aplicações que lidam com mensagens grandes.


Na operação de verificação, observou-se um padrão semelhante ao da assinatura, porém com diferenças mais pronunciadas entre as plataformas. Em mensagens pequenas e médias, o ML-DSA e o Falcon voltaram a apresentar desempenho altamente competitivo, com tempos próximos aos dos algoritmos clássicos. O SPHINCS+, em contraste, manteve tempos substancialmente maiores, sobretudo nas variantes \textit{s-simple}. Com mensagens grandes (100 MB), o comportamento divergiu entre os ambientes: no Raspberry Pi, o ML-DSA e o Falcon preservaram resultados satisfatórios e permaneceram próximos aos clássicos, enquanto no Ubuntu seus tempos cresceram de forma mais acentuada, aumentando a distância relativa — ainda assim, dentro de uma faixa considerada viável. Nesse mesmo cenário, as variantes \textit{f-simple} do SPHINCS+ baseadas em SHA2 mostraram desempenho expressivamente melhor que nas mensagens menores, tornando-se alternativas consistentes para casos em que a verificação de dados extensos é mais frequente.


Nas operações de assinatura e verificação, observou-se um comportamento bastante consistente entre as duas etapas. Em mensagens pequenas e médias (256~bytes e 100~kB), o ML-DSA e o Falcon apresentaram tempos praticamente equivalentes e altamente competitivos, próximos aos dos algoritmos clássicos, enquanto o SPHINCS+ permaneceu bem atrás, especialmente nas variantes \textit{s-simple}. 
Com mensagens grandes (100~MB), ocorreram mudanças nos resultados. Na assinatura, o ML-DSA e o Falcon continuaram entre os melhores esquemas pós-quânticos, mantendo-se muito competitivos no Raspberry Pi, mas com queda de desempenho no Ubuntu, onde se distanciaram um pouco dos clássicos, embora ainda dentro de uma faixa viável. Nessa condição, as variantes \textit{f-simple} do SPHINCS+–SHA2, em especial a SHA2-128f, se destacaram, chegando a superar ML-DSA e Falcon e tornando-se uma alternativa sólida para o processamento de mensagens extensas. Na verificação de mensagens grandes, o padrão foi semelhante: no Raspberry Pi, o ML-DSA e o Falcon mantiveram resultados competitivos, mas foram superados pelos SPHINCS+–SHA2; já no Ubuntu, novamente se afastaram um pouco dos algoritmos clássicos, porém dentro de limites aceitáveis, enquanto as variantes SHA2 continuaram se destacando como as mais eficientes entre os pós-quânticos .

No ciclo completo, os padrões gerais se confirmam. Com mensagens pequenas e médias, o ML-DSA foi o mais rápido entre os pós-quânticos, seguido de perto pelo Falcon, ambos muito competitivos com o ECDSA. As variantes \textit{f-simple} do SPHINCS+ ficaram em posição intermediária, enquanto as \textit{s-simple} apresentaram desempenho bem inferior. Com mensagens grandes, o comportamento variou conforme a plataforma: no Raspberry Pi, ML-DSA e Falcon mantiveram tempos competitivos e as variantes \textit{f} do SPHINCS+ também obtiveram aceitáveis; já no Ubuntu, o ML-DSA e o Falcon se distanciaram um pouco mais dos clássicos, embora ainda dentro de limites aceitáveis. Nessa mesma condição, as versões SPHINCS+–SHA2–\textit{f} chegaram a apresentar tempos comparáveis, e em alguns casos até melhores que ML-DSA e Falcon, reforçando seu potencial em cenários de alta carga de dados.

Quanto ao consumo de memória, para mensagens pequenas e médias todos os algoritmos apresentaram valores relativamente próximos, geralmente entre 1~MB e 2~MB. As diferenças 
entre variantes de mesmas famílias também foram pequenas no geral. No Ubuntu, os SPHINCS+–SHAKE tendem a consumir um pouco menos memória que as demais famílias, enquanto no Raspberry Pi o ML-DSA se destacou com o menor consumo.
Por outro lado, nas mensagens de 100~MB observou-se um salto significativo no consumo dos algoritmos pós-quânticos, todos convergindo para cerca de 202~MB de pico líquido. Os algoritmos clássicos, em contraste, mantiveram consumo praticamente inalterado de cerca de 1MB, o que indica que não realizam realocação adicional relevante. Assim, a diferença entre os algoritmos clássicos e pós-quânticos torna-se extremamente acentuada em entradas muito grandes, embora esse comportamento possa estar mais relacionado às diferentes bibliotecas utilizadas para algoritmos clássicos e poś-quânticos, do que aos algoritmos propriamente ditos. Investigações futuras serão necessárias para compreender com maior precisão se esse aumento expressivo de consumo de memória decorre de características intrínsecas dos esquemas pós-quânticos ou de decisões específicas de implementação adotadas nas bibliotecas atuais, como o gerenciamento de buffers e estratégias internas de alocação.
